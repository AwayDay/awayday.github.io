---
layout: post
title: "제어 역전과 의존성 주입"
description: "스프링은 무슨 일을 하는가?"
tags: [study, Spring, Java]
---

# IoC : 제어 역전
* __개념__ : 프로그램의 제어권이 나(개발자, 또는 __객체__ )에게서 특정 객체, 또는 프레임워크에게 넘어감
    * 일반적인 코딩 : 내가 호출한 순서대로 호출됨, 객체는 자신이 무엇을 생성하고 무엇을 할지 알고 있음.
    * 제어 역전이 일어난 경우 : 어.... 나는 어디서 생성되지?(근본적 문제) / 나 어디서 쓰임....? / 내가 그러니까.... 뭘 쓰게 되는거냐?
        * 객체가 능동적 존재에서 수동적 존재로 격하.
        * 객체의 제어 권한을 위임받은 특별한 오브젝트가 객체의 생성, 의존, 사용을 결정함.
        * 스프링 환경에서는 : 스프링(=프레임워크)이 다 알아서 해주실거야.
            * 프레임워크가 흐름을 주도하며 등록된 객체와 코드를 사용함.
* __예시__ : 팩토리 오브젝트
    * 객체를 생성하고, 의존성 있는 객체도 넣어주고 하지만 정작 대상 객체는 팩토리에 끌려다님.
* 아니 미친 그럼 팩토리랑 제어 역전은 뭐가 달라 : 아래에서 봅시다.

> 팩토리의 예시에서도 알 수 있듯, 사실 IoC는 꼭 프레임워크를 사용해야 하는 거창한 개념은 아니다.

## 용어 확립
* __빈__ : 스프링이 주도권을 가지고 생성, 의존 설정 등이 가능한 오브젝트
    * 그러니까 스프링이 공을 가진 객체
    * 스프링은 빈을 IoC 방식으로 관리한다
        * __관리되는 객체__
* __빈 팩토리__ : 빈의 생성과 관계설정을 담당
    * 빈을 : 등록 생성 조회 반환 둥둥
* __애플리케이션 컨텍스트__ : 빈 팩토리의 확장, 빈을 넘어 애플리케이션 전반의 제어 작업이 가능하다.
    * 애플리케이션 차원의 지원 기능
* 설정 정보(메타 정보) : 빈 팩토리가 IoC를 적용하기 위해 작성된 메타정보
* 컨테이너(IoC 컨테이너) : 애플리케이션 컨텍스트, 또는 빈 팩토리
    * IoC 방식으로 빈을 컨트롤 한다는 의미임.

## 스프링을 통한 제어 역전
* 간단하게 만드는 법 : 기존의 팩토리 오브젝트를 활용한다
    * __@Configuration__ : 클래스 선언 위에 붙인다. 빈 팩토리, 또는 애플리케이션 컨텍스트가 사용할 정보를 담은 클래스임을 선언하는 것.
    * __@Bean__ : 생성 메서드 위에 붙인다. 빈을 생성하는 IoC용 메서드임을 표시한다.
        * 메서드가 빈이 아니라 빈을 만드는 메서드임에 유의.
        * 메서드를 통해 생성된 오브젝트(반환형)는 빈이 맞다.
* 간단하게 쓰는 법 : 위에서 개조한 팩토리 오브젝트에 붙은 설정 정보를 쓴다

```java
// 애노테이션으로 설정한 컨텍스트 정보를 읽어온다(아마)
ApplicationContext ac = new AnnotationConfigApplicationContext(AFactory.class);
// 생성 메서드를 찾아서 빈을 만들고 타입 변환해서(Object -> MyBean) 반환한다.
// MyBean을 반환하는 메서드는 여러 개일 수 있기 때문에, 꼭 생성하는 메서드의 이름을 써줘야 한다.
MyBean mb = c.getBean("myBean", MyBean.class);
```  

### 애플리케이션 컨텍스트의 동작
1. 클라이언트에서 애플리케이션 컨텍스트에게 빈을 요청
2. 애플리케이션 컨텍스트는 빈을 찾아보고, 존재하면 빈 생성 메서드를 호출.
3. 생성된 객체를 클라이언트에 던져줌.

### 생짜 팩토리와의 비교
* 애플리케이션 컨텍스트가 더 범용적이고 유연함
* 팩토리 객체와 비교해봤을 때의 장점
    * 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다
        * 이름도 몰라요 얼굴도 몰라요 하지만 컨텍스트한테 물어보면 알려주겠지.
    * 애플리케이션 컨텍스트는 생성과 관계 설정 차원을 넘어 오브젝트를 효과적으로 사용할 수 있는 기능 제공
        * 가장 잘 느껴지는 부분이 후처리 : 반환
        * 빈의 기반 서비스나 외부 시스템과의 연동 기능을 제공하기도 함.
    * 애플리케이션 컨텍스트는 빈을 검색할 수 있는 다양한 방법 제공.
        * 이름 뿐만이 아니라, 타입만 가지고 빈을 검색하거나, 애노테이션 설정이 된 빈을 찾거나.

### 싱글톤 레지스트리
* getBean()을 통해 생성되는 빈은 기본적으로 싱글톤 객체이다
    * 엔터프라이즈 애플리케이션에 가해지는 객체 생성 부하를 막기 위함
    * 싱글톤은 다루기 힘들다 : 빈이 싱글톤이면 스레드 안전을 위해 상태를 가지지 않게 해야 한다.
        * 아니 그럼 정보를 어떻게 다뤄요 : 파라미터, 로컬 변수(메서드 내부의), 리턴 값 등 활용
        * 물론 읽기 전용 값은 인스턴스 변수로 냅둬도 상관 없음
            * 리드 / 라이트 락을 다시 한번 떠올릴 기회.
* 싱글톤 객체를 관리하는 기능을 제공하는 스프링 요소가 __싱글톤 레지스트리__

### 빈의 스코프
* = 빈의 존재범위
* __예시__ : 싱글톤 빈의 싱글톤 스코프는 컨테이너 내에 딱 하나, 컨테이너 존재하는 동안 존속.
* __기본값__ : 싱글톤
* 싱글톤 말고는? : 다양하다, 아래는 예시.
    * 프로토타입 스코프 : 컨테이너에 빈을 요청할 때마다 새로운 오브젝트를 생성해줌
    * 요청 스코프 : (HTTP Requsest)
    * 세션 스코프 : 웹의 세션과 유사하다 함.

# DI : 의존성 주입
* 의존성의 아이를 낳아라! 그/아/아/앗

## IoC의 문제점
* __아니 뭐 기능에 문제가 있는건 아니고....__
* 용어가 과하게 포괄적임
    * 스프링은 IoC 컨테이너이다 -> 어.... 그래서 무슨 IoC?
        * 서버에서 돌아가는 컨테이너니?
        * IoC 개념이 들어간(템플릿 메서드 등) 프레임워크니?
        * 아니면 듣도보도 못한 신기술?
* 그래서 등장한 새로운 용어 : __DI = 의존성 주입__

## 의존관계란 무엇인가.
* 의존관계는 두 개의 클래스 이상에서 성립함.
* A가 B에 의존한다.
    * = B가 변하면 그 영향이 A에 미친다.
        * 예시 : A에서 B의 메서드를 호출
            * B의 메서드 정의가 수정 : A는 수정되어야 함
            * B의 메서드 내부 기능이 변경 : A 기능수행에 영향

### 느슨한 의존관계
* 인터페이스에 대해서 의존관계를 성립한다
* = 인터페이스에 명시된 메서드에 대해서만 의존함
    * 인터페이스 구현체가 바뀌거나, 내부적으로 사용할 추가 메서드가 생긴다거나 해도 큰 영향이 없다.
    * 정의만 잘 지켜주면
* 의존성 있는 대상의 변화에 영향을 덜 받게 됨.
    * 이런 것을 결합도가 낮다고 할 수 있겠다.

### 의존 오브젝트
* 인터페이스를 통해 느슨한 의존 관계를 만들었을 경우에 발생하는 개념
* 인터페이스는 그 자체를 쓸 수 없고, 구현체를 만들어 사용하여야 함.
    * 그럼 내가 어느 구현체에 의존하게 될지 어떻게 알아?
    * 런타임에나 알게 되겠지 바보야!
* __의존 오브젝트__ : 실제 사용하는 의존 대상.

## 의존관계 주입
* __의존 오브젝트__
* __객체(의존 오브젝트를 사용하는)__
* __클라이언트(객체를 사용하는)__
* 위 세 가지 오브젝트들을 런타임에 연결하는 것
* __조건__
    1. 클래스 모델, 코드에는 런타임 시점의 의존관계가 드러나면 안됨
        * 그래서 인터페이스에 의존함.
    2. 런타임 시점의 의존관계는 컨테이너나 팩토리같은, 제 3의 존제가 결정함.
    3. 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 주입해주어 생겅.
* __결론__ : 설계 시점에는 알지 못하였으나, 어쨌든 관계 설정을 도와주는 제 3의 존재가 등장.
    * 관계 설정 책임을 분리함
    * 이것도 관심사의 분리인가?
    * 결국 간단하게 말하면 의존성 넣어주는 팩토리임.

```java
// 객체의 의존성 주입 기본
public class MyBean{
    private Dependency dependency;
    // 외부에서(팩토리 등) 의존성을 주입해주는 부분.
    public MyBean(Dependency dependency){
        this.dependency = dependency;
    }
}
```  

## DI의 조건
* 객체 외부에서 의존성을 넘겨받았다고 해서 무조건 DI인가? : 아님
* 주입 받은 의존성이 특정 클래스로 고정되어 명시되어 있다면 이건 다이나믹한 모양이 아니다.
* __참된 DI는 오직 인터페이스 타입의 파라미터를 통해 이루어질 것이며, 객체는 어떤 구현체를 받을지 모르는 상황이어야 한다!__

## 장점
* DI를 왜 쓰겠는가, 이점이 있어서 쓰는 것 아니겠는가.

### 기능 교체
* 개발할 때엔 이 코드, 테스트 할 때엔 저 코드, 런칭에는 요 코드를 사용해야 한다, 어떻게 해야 할까?
* 의존성 들어가는 부분만 수정해주면 된다!
    * 예쁘게 구성된 코드에서는, 팩토리의 빈 생성 부분 한 줄(혹은 적은 줄)만 수정해주면 해당 객체에 의존하는 모든 객체에 영향이 간다.
    
### 부가(중간)기능 추가
* 아, 지금 A와 B를 연결해놨는데, 중간 기능을 넣고 싶어, 어쩌지?
    * B를 받는 A에서 B를 받는 C(중간기능)를 받는 A 모양으로 만들면 됨
    * 내일의 나 : '뭔 개소리야....'
    * B에서 A를 만들던걸 B를 받은 C가 A를 만들어줌.
* 아 모르겠다 여하간 중간기능 만들어서 중간에 끼워주면 된다

## 생성자가 아닌 방법으로 하는 DI
* 세터 메서드
    * 주로 외부에서, 오브젝트 내부의 애트리뷰트 값을 바꿀 때 사용
* 그냥 아무 메서드
    * 여러 파라미터를 가질 수 있다.


# 메모
* 간단하게 떠오르거나 깨우친 내용을 정리

## 펙토리의 의의
* 팩토리는 객체(A)와 의존 대상(B) 사이의 관계를 성립해 객체를 만들어내는 것에 의미가 있는 것 같다.
    * 그래서 A를 만들어내는 팩토리는 B를 만들어내는 역할도 겸할 수 있어야 한다고 생각.
    * A와 B를 혼합해서 완성품을 낸다고 이해하면 내가 제대로 이해한 것이 맞으련가.
        * 완성 객체 제조 공장은 A 생산라인과 B 생산라인이 모두 있어야 한다
            * 아 님, 그럼 부품 하청생산은 뭐에여 ㅡㅡ
                * new B();