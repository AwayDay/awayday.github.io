---
layout: post
title: "관계형 모델이란"
description: "오쿠노 미키야, 원리부터 배우는 관계형 데이터베이스 실전 입문, 위키북스(2016)"
tags: [db, rdb]
---

# 들어가기 전에
* [원리부터 배우는 관계형 데이터베이스 실전 입문](http://wikibook.co.kr/rdb-in-practice) 1-2장 요약정리 및 감상.

# 집합과 관계형 모델

## 관계형 모델

> 하지만 관계형 모델이 나타내는 데이터 모델은 설계의 의미가 아니고 "데이터를 어떻게 표현할까" 라는 개념의 의미다.

> 관계형 모델(relational model)은 프레디커트 로직과 집합 이론에 기반을 둔 일종의 데이터베이스 모델이다. [위키피디아, 관계형 모델](https://ko.wikipedia.org/wiki/%EA%B4%80%EA%B3%84%ED%98%95_%EB%AA%A8%EB%8D%B8)

관계형 모델은 데이터 모델의 여러 갈래 중 하나이고, 데이터 모델은 __데이터를 표현하는 방법__ 의 하나이다. 

* 다른 유명한 데이터 모델로, No-SQL DB에서 많이 사용하는 Key-Value 모델을 들 수 있음

### 관계형 모델과 SQL, ERD

물론, 관계형 데이터베이스는 관계형 모델을 차용하고 있다. 그렇다면 관계형 데이터베이스(더 정확히는 RDBMS)에서 관계형 모델과 나머지 구성요소(SQL, ERD 모델)의 관계는 어떻게 될 것인가. 결론만 말하자면 __큰 연관관계가 없다__.

## 관계 그 자체

> 계속해서 말하지만 테이블 사이의 관계를 (ERD 등을 사용해) 디자인하는 것이 관계형 모델이라고 오해하는 사람들을 꽤 볼 수 있다.

관계형 모델에서, 릴레이션(보통 관계라고 번역하는)이라 할 수 있는 것은 테이블에 해당한다.

### 관계형 모델의 릴레이션

관계형 모델에서, 릴레이션은 속성의 집합인 머리와 요소(튜플)의 집합인 몸통으로 이루어진다.

* 릴레이션 = 머리 + 몸통
    * 머리 : N개의 속성 집합
        * 속성 : 각 속성은 속성의 이름과 데이터 형으로 정의
    * 몸통 : 머리에서 정의한 __속성값__ 의 집합 = 튜플
        * 속성값은 속성에서 정의한 값의 도메인 내에 존재해야 함

아래 테이블은 릴레이션의 가장 단순한 정의를 만족한다.

| 사번(String) | 이름(String) | 출생년월(date) |
| ---- | ---- | ---- |
| NE00001 | ㄱㄱㄱ | 1965/02 |
| NE00002 | ㄴㄴㄴ | 1978/11 |
| NE00003 | ㄷㄷㄷ | 1980/08 |

## 집합 관점에서 본 릴레이션

> 릴레이션도 집합의 한 종류이므로 집합이 가진 특성은 릴레이션에서도 응용할 수 있다.

릴레이션을 정의할 때, 집합이라는 말을 많이 사용하고 있다. 관계형 모델에 대한 설명에서도 `...집합 이론에 기반해...` 라는 부분이 눈에 띈다. 그렇다면 우리가 만드는 테이블도 집합의 특성을 나타내야 함이 옳다. 집합이란 무엇인가?

* 집합 : 요소(또는 원소)의 모임을 표현하는 개념

여기서 요소는 흔히 말하는 데이터형(문자열, 정수형과 같은)을 포함한 모든 것이 될 수 있다. 릴레이션에서 개별 요소(튜플)는 연관된 속성값의 집합이라 할 수 있을 것이다.

### 집합의 조건

집합에서 가장 중요하게 여기는 것은 __포함 여부__ 이다.

* 어떤 요소가 집합에 포함되어 있는지를 확정할 수 있어야 한다
* 집합의 요소가 중복되어선 안 된다
    * 더 정확히는, ``특정 요소가 집합에 몇 개 포함되어 있는가?`` 가 다음 연산에 영향을 주어서는 안 됨
* 요소는 더 이상 분해될 수 없어야 한다
    * 특정 요소가 다른 요소의 일부로 들어갈 수 있다면, 이는 포함 여부 판정에 영향을 주게 됨

### 슈뢰딩거의 NULL

> 반면 NULL은 값이 존재하지 않고나 알 수 없다는 의미의 특별한 기호이며 값이 아니다.

NULL 자체는 값이 아니며, __알려지지 않은 상태__ 를 의미한다. 그리고 이런 특징이 관계형 모델, 릴레이션에서 NULL을 환영하지 못하게 한다.

| 사번(String) | 이름(String) | 출생년월(date) |
| ---- | ---- | ---- |
| NE00001 | ㄱㄱㄱ | 1965/02 |
| NE00002 | ㄴㄴㄴ | 1978/11 |
| NE00003 | ㄷㄷㄷ | 1980/08 |
| NE00004 | ㄹㄹㄹ | NULL |

위 테이블에서, 나이가 50세 이상인 사람들을 추출(제한)하고자 한다면, ㄹㄹㄹ씨는 어떻게 판단해야 하는가? 

* 추출된 릴레이션에 ㄹㄹㄹ씨를 자신있게 포함할 수 있는가? 
* 아니면, 릴레이션에서 확신을 가지고 제외할 수 있는가?

또는, 다른 테이블과 `출생년월` 속성을 기준으로 조인할 경우에는 어떻게 판단할 것인가?

### 집합의 연산

릴레이션의 연산 또한 집합론에 기반을 두고 있다. 모든 연산의 결과는 새로운 릴레이션을 반환한다. SQL 쿼리를 잘 뜯어보면, 메서드 체이닝과 유사하다는 인상을 받을 수 있다.

```sql
SELECT
    t1.column1, t2.column2, t2.column3 ...
FROM
    table1 t1, table2, table3 ...
WHERE
    t1.column1 = ''
    t2.column2 > 00
```

예를 들어, 흔히 볼 수 있는 위 SELECT 문은 릴레이션의 곱집합(FROM) + 제약(WHERE) + 프로젝션(SELECT) 연산이 합쳐진 질의이다. 각 연산은 연산 결과로 릴레이션을 반환하고, 다음 연산은 이전 연산의 결과 릴레이션을 받아 연산을 수행한다.

# 논리와 관계형 모델

## 명제와 논리, 그리고 증명

> 명제란 어떤 사물에 관해 설명한 문장이 그 의미가 정확한지, 즉 참인지 거짓인지 물을 수 있는 것이다.

* 명제는 참 / 거짓으로 명확히 답할 수 있는 문장
    * 객관적이고 변하지 않아야 함
* 상태를 알고 있는 어떤 명제로부터, 상태가 알려지지 않은, 연관된 다른 명제의 참 / 거짓 여부를 알기 위해 __명제논리__ 를 사용
    * AND, OR, NOT 등이 명제논리=논리연산에 해당

그렇다면 상태가 알려지지 않은 명제를 어떻게 증명하는가? 이럴 때에 이미 증명된 사실(혹은, 참인 것으로 결정한 사실)인 공리와 공리계를 사용한다.

### 모순의 위험성

* 모순된 상태란, 간단히 말하면 `(A && !A)` 을 의미한다.

짐작과 같이, 위 상태는 무조건 거짓을 나타낸다. 그런데 이 때, 포함이 등장하면 어떻게 될까?

* `(A && !A) ⊃ B`

B는 본래 A와 아무 연관이 없다(사실 있어도 없어도 아무 상관이 없다). 그런데 갑자기 포함관계로 튀어나온 명제다. 이렇게 되었을 때 전체의 결론은 어떻게 되는가? 포함관계의 진리표를 보자.

|P|Q|P⊃Q|
| - | - | - |
| T | T | T |
| T | F | F |
| F | T | T |
| F | F | T | 

B의 참 / 거짓 여부에 관계 없이, 전체 결론은 참이 된다. 이는, 모순되는 명제가 포함되어 있을 경우, 이 명제를 가정으로 삼은 증명에서는 어떠한 결과도 얻을 수 없다는 것을 의미한다.

## 양화논리의 등장

> 그런데 세상에는 명제논리만으로 해결할 수 없는 논리학적인 문제가 많이 있다.

명제에도 한계는 있다. 이는 집단을 대상으로 할 때 나타나는데, 아래 예시를 보자.

* 모든 AA는 XX이다.(어떤 AA도 XX가 아니지 않다.)
* 어떤 BB는 YY이다.(모든 BB가 YY라고 할 수는 없다)

위 예시는 명제가 명확히 표현할 수 없다. 이러한 문제를 해결하기 위해 __양화논리__ 가 등장하였다. 양화논리는 아래와 같은 상황에서 사용 가능하다.

* 어떤 집단의 요소 전체가 어떠한 상태를 충족
* 어떠한 상태를 충족하는 요소가 어떤 집단 내에 존재

양화논리는 주로 __어떤__ , __모든__ 이라는 표현(이를 ∀, ∃로 표현하고, 범용정량자라 읽는다.)을 사용하여 표현한다.

### 술어논리

술어논리는 범용정량자를 사용하여 표현한 논리식에 함수와 변수 개념을 대입하여 더욱 간단하게 표현한 표현 체계를 의미한다.

술어와 집합은 등가교환 되는데, 집합의 모든 튜플은 집합이 정의하는 속성을 만족하기 때문이다.

| 사번(String) | 이름(String) | 출생년월(date) |
| ---- | ---- | ---- |
| NE00001 | ㄱㄱㄱ | 1965/02 |
| NE00002 | ㄴㄴㄴ | 1978/11 |
| NE00003 | ㄷㄷㄷ | 1980/08 |

예를 들어, 위 테이블(집합)의 __모든__ 데이터는 `#######사번을 가진 XXX씨의 출생년월은 yyyy/mm 이다` 를 만족한다.

## 릴레이션과 논리

> 이 사실에서 유추되는 결론은 __릴레이션에는 대응하는 술어가 있다__ 는 것이다.

간단하게 설명하면, 릴레이션의 모든 튜플은 __참인 명제__ 이다.

* 릴레이션의 변천사
    1. 속성과 속성값의 집합
    1. 참인 명제의 집합

릴레이션의 모든 데이터가 명제라면, 모순된 데이터를 포함하는 릴레이션은 자신을 포함하여 자신이 연관된 모든 질의에서 엿을 날리는 지뢰와 같다. 모순된 데이터와 그에 대응하는 법은 3장부터 나온다.

# 더 간단하게 요약

1장과 2장은 관계형 모델을 이해하기 위한 이론적 토대를 설명하는, 일종의 입문 파트이다. RDB에 대해 이제 막 배웠거나, 막연한 이미지만을 가진 사람이라면, 이 두 챕터를 읽는 것만으로도 정신개조(...)가 되는 것을 느낄 수 있다(내가 그랬다).

테이블 정규화나 NULL에 대처하는 법, SQL을 효율적으로 휘두를 수 있게 하는 법, 관계형 모델로 표현할 수 없는 자료구조(=그래프)에 맞서는 법 등, 정말 실전적이고 중요한 내용은 3장 이후부터 나오니 책을 사서 읽어보자!

무엇보다, 표지가 예쁘다. 나는 이것 때문에 위키북스를 좋아한다.