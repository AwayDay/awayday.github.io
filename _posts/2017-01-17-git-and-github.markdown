---
layout: post
title: "Git와 Github"
description: "형상관리의 묘"
tags: [study, Git]
---

# 들어가기 전에
* 이 포스트는 2017.01.17 NHN Ent. 기술 강의 시간에 들은 내용을 바탕으로 작성되었음.
* __그리고 작성 중임__

# 버전 관리 시스템
* 파일의 변화를 시간에 따라 기록하여 특정 시점의 버전으로 다시 불러올 수 있음
* 개별 파일 또는 프로젝트 전체를 이전 상태로 되돌릴 수 있음
* 시간에 따른 변경 사항을 기록 검토
* 문제가 되는 부분을 누가 수정하였는가 확인 가능
* 파일이 누락되거나 잘못된 경우에도 쉽게 복구 가능

## 버전 관리 이전엔
* 폴더 등으로 관리했지

## 로컬 버전 관리 시스템
* 대부분의 사람들이 버전 관리를 하기 위해 디렉터리나 파일 등을 복사해둠
* 인력 = 실수할 가능성 많음
* 그래서 고대의 선각자들은 디비에 파일 이력을 저장하는 시스템을 개발하였음.

### 문제점
* 나 혼자 쓰면 유용함
    * 우왕 ㅋ 굿 ㅋ
* 그런데 같이 쓰면....?

## 중앙 집중식 버전 관리 시스템
* SVN 등
* 파일을 저장하는 하나의 서버 존재
* 중앙에서 파일을 가져오는 각각의 클라이언트(=개발자)

### 장점
* 누구나 다른 사람이 무엇을 하고 있는지 알 수 있음
* 수많은 클라이언트의 로컬 디비를 관리하는 것보다는 중앙 디비 관리가 훨씬 쉬움

### 단점
* 중앙집중식 = 중앙이 죽으면....?
        * 아 망했어요 아 망했어요
* 서버가 다운되면 복구 때까지 협업도 뭐도 아무 것도 못함.

## 분산 버전 관리 시스템
* Git 등
* 서버의 복제를 각 클라이언트에서 가지고 있음
* 서버가 죽어도 어느 누군가의 복제를 서버에 다시 올리면 됨, 간단!
        * 그나마

# Git
* 우리의 아이돌 리누스 토발즈 아재가 개발
    * 비트키퍼라는 상용 형상관리 툴이 있었는데, 개발이 중단됨
    * 음 내가 만들면 되겠군
* 빠른 속도, 단순한 구조, 비선형 개발, 완전한 분산, 대형 프로젝트에서도 유용할 것을 목표로 함.

## 스냅샷
* Git의 변경 이력 저장 방식
    * SVN은 델타로 저장함
* 스냅샷의 특징
    * 그냥 변경된 파일이 있으면 통째로 저장함
    * 특정 시점으로 체크아웃 하는 속도가 굉장히 고속 : 스냅샷을 받아오면 장땡이니....

## 로컬
* 거의 대부분의 명령이 로컬에서 실행됨
    * 물론 푸시 풀은 빼고
    * 형상관리에 있어 핵심적인, 대부분의 동작이 로컬에서 돌아감

## 무결성
* 깃은 어떻게 데이터를 저장할까?
* 해시와 체크섬
    * 파일에 대한 체크섬을 구해서
    * 무결성을 체크합니다.
* .git 디렉터리의 하위를 보면
    * 어떤 가지의 폴더를 들어가서, 아무 파일이나 열어보면 체크섬 달랑 있음.

## 상태

### 커미티드
* 어떤 파일이 깃 저장소에 저장된 상태

### 모디파이드
* 커미티드 된 파일에 수정이 발생하였을 때.

### 스테이지드
* 모디파이드 된 파일을 커밋하기 위한 준비 단계

## 대강의 작업 플로우
* 워킹 디렉터리에서 파일 수정(모디파이드)
* 스테이지에 올리기(스테이지드)
* 커밋(커미티드)

## 파일 수정과 상태 변경
* 워킹 디렉터리 내용의 파일은 트랙드와 언트랙드로 분류됨
    * 트랙드 : 버전 관리 잘 되는 파일
        * 이미 스냅샷에 포함
        * 언모디파이드 : 커밋 이후 수정된 것이 없는 상태 
        * 모디파이드 : 짜잔! 수정하였습니다.
        * 스테이지드 : 스테이지에 올라간 상태
    * 언트랙드 : 버전 관리에서 제외되어 있는 파일
        * 파일이 생성된 상태
        * 파일 추가가 필요함.
* 언트랙드 -> 스테이지드 -> (커밋) -> 언모디파이드 -> 모디파이드

# add
* `git add ~`
* 모디파이드 상태의 파일을 스테이지드 파일로 만드는 명령어
* 나처럼 뒤도 안 돌아보고 `git add .` 하는 인간에겐 백약이 무효하다.

# commit
* __커밋__ : 버전 관리 시스템에서 포인트를 만드는 것을 이름
    * __커밋 로그__ : 어떤 커밋에 관한(=포인트에 관한) 설명
* `git commit -m "comment"`

# breanch 브랜치
* 개발의 큰 줄기, 여러 워킹 디렉터리를 생성.
* 실제 개발 과정에서의 사용
    * 작업 중인 프로젝트
    * 새로운 이슈 처리를 위해 브랜치 생성
    * 새로 만든 브랜치에서 작업을 진행
* 다른 예시 : 문제 수정 중 중요한 문제가 생겨서 급하게 핫픽스를 해야 한다.
    * 새로운 이슈를 처리하기 위해 가장 최신의 운영 브랜치로 이동함.
    * 핫픽스 브랙치 생성
    * 수정한 핫픽스 테스트를 마치고 운영 브랜치로 머지함
    * 다시 작업하던 브랜치로 돌아가 이슈 해결 진행.
* 가상의 작업 공간.

## 깃이 데이터를 저장하는 방법
* 깃이 브랜치를 어떻게 다루는가?
* 깃 커밋 -> 커밋 객체 생성
    * 커밋 객체 : 스냅샷에 대한 포인터, 메타 데이터, 이전 커밋에 대한 포인터.
        * __이전 커밋이 무엇인지 저장__
* 브랜치는 커밋을 가리키는 포인터임.
    * 커밋은 커밋 객체를 가리키고, 커밋 객체는 스냅샷을 가리키고

## HEAD
* 현재 커밋 위치를 가리킴.

## Tag
* 출시 관리용
* 보통 버전 명
* 특정 커밋을 가리킴, 이 점에서 사실상 브랜치랑 비슷함.

## 체크아웃
* 워킹 디렉터리의 상태를 해당 브랜치의 워킹 디렉터리로 변경하는 것.

## 머지
* 깃은 뭔가 하려면 내가 뭔가 작업하길 원하는 브랜치로 체크아웃을 해 주어야 함.
* 머지가 되면 해당 커밋(머지-커밋)은 부모가 두 개임
* 음, 브랜치를 지워야겠네.

## 브랜치 삭제
* 다른 브랜치로 체크아웃 한 다음에 해야 함.
* 이 경우 브랜치(=포인터)는 삭제되나 해당 그래프의 커밋 내용이 실제로 삭제되는 것은 아니다.

## Fast-Forward
* 한 쪽에는 변화가 없고, 한 쪽은 커밋이 주르륵 올라간 상태
* 이 상태에서 뒤쳐진 쪽에 앞서간 쪽을 머지하면
* 뒤쳐진 쪽 포인터가 앞으로 파밧 이동함
* 따로 커밋도 필요 없음, 끝.

## Git-Flow
* 브랜치 관리 모델
* 겁나 유명해진 관계로 이걸 지원하는 툴이 많음
* __메인 브랜치__
    * 항상 존재하는 브랜치들
    * __master__ : 배포된 소스가 있음
    * __develop__ : 다음 배포를 위한 소스가 있음.
        * 개발이 완료되면 master로 머지 됨.
* __서포팅 브랜치__
    * 팀 멤버들이 병렬로 일할 수 있도록 도와주는 브랜치
    * 필요에 의해 생겼다 사라졌다 함
    * __feature__ : 디벨롭에서 생성, 디벨롭으로 머지
        * 특정 기능에 대해 디벨롭에서 분리되어 개발 후, 디벨롭으로 돌아감.
        * 개발한 기능을 커밋으로 구별할 수 있게 하기 위해 패스트 포워드를 사용하지 않음.
    * __release__ : 디벨롭에서 생성해서 디벨롭과 마스터로 머지됨(두 군데 다)
        * 프리픽스는 주로 release/
        * 배포 준비 브랜치, 주로 배포 직전에 브랜치됨.
        * 메타 데이터 변경, 작은 버그 수정
        * 배포 준비 완료 후 마스터와 디벨롭에 __각각__ 머지함.
            * 배포 준비를 위한 것이기 때문에 일단 마스터에 머지한다.
            * 그리고 다시 디벨롭에 머지 해야지 최신 변경 사항이 반영되어 개발이 계속 이어진다.
    * __hotfix__ : 마스터에서 분리, 디벨롭과 마스터로 머지함.
        * 주로 hotfix/

# 원격 저장소 : Remote
* 깃은 로컬 저장소로만 사용할 수도 있지만
    * 원-격 저장소를 추가하여 힘세고 강한 협업이 가능.
* 깃허브에서 클론하면 깃허브 레포지터리 주소가 origin으로 추가되어 있음.
    * __origin__ : 기본 리모트 저장소

## 원격과 로컬의 차이
* 오리진 마스터와 로컬 마스터는 서로 다른 브랜치!
    * 야 생각해봐 니 마스터랑 니 옆사람 마스터가 같냐
    * 그런거임.

# Fetch
* 원격 저장소의 변경 사항을 내려 받는 것.
    * 패치 까지만 하면 변경 사항만 받았지 로컬에는 머지 되지 않은 상태.
* 로컬 브랜치에 원격 저장소의 변경 사항을 반영하고 싶다면 수동으로 원격 브랜치를 로컬 브랜치로 머지해야.

# Pull
* = 패치 + 머지
* 변경사항 받은 후 로컬에 머지함.

# Push
* 로컬 저장소의 변경 사항을 원격 저장소로 올림.

# 충돌
* 보통 두 브랜치에서 동일한 라인을 고쳤을 경우 충돌 발생 
* 일단 충돌을 내 보자
    * 같은 라인에 대해 두 다른 브랜치에서 수정 발생
    * 풀 리퀘스트
    * 둘 중 먼저 머지 된 것은 머지가 될 것이나, 다음은 충돌이 날 것이다.
* 디벨롭으로 체크아웃 후 풀
* 당연히 충돌
* 충돌 난 파일을 확인 후 충돌 영역을 잘 보고 적절히 수정
* 충돌이 안 난다!
* .... 는 간단한 이야기인데.

# 실습

## 일단 깃허브 레포지터리를 만들자
* [GitHub](https://github.com/)

## 클론 받기
* `git clone {주소}` 또는 __저장소 복제__

## 이름, 이메일 주소 셋팅
* 도구 - 옵션
    * 사용자 정보에서 이름과 이메일을 셋팅한다.

## 파일 수정
* 언 모디파이드 상태의 파일을 모디파이드 상태로 만들어봅시다.
* 바꾼 적이 없는데 수정이 되었다고 나오는 이유 : \n \t \r...
* 스테이지드 된 상황에서 다시 수정을 하면 어떻게 되나여?
    * 스테이지드 된 수정 전 파일과
    * 모디파이드 상태인 수정 후 파일이 공존하는 기묘한 상태를 연출

## 커밋
* 커밋 로그와 함께 커밋하면 된다.

## 깃 플로우 설정
* 공유하는 레포지터리를 클론 받아서
* 기본 브랜치가 디벨롭이라 디벨롭만 딸려왔네, 이러면 깃 플로우 설정이 안 된다.
* 오리진에서 마스터 체크아웃 받으면 마스터도 생김.
* 깃 플로우 버튼을 눌러 깃 플로우 생성.

# 여담
* 그래바타라는 사이트에 이메일 등록해서 프사 올리면 깃허브에서도 나오고 비트버킷에서도 나오고(덩실)
