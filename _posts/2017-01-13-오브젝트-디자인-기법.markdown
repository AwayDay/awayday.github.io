---
layout: post
title: "오브젝트 디자인 기법"
description: "토비의 스프링 1장을 느긋하게 읽는 중"
tags: [study, spring, java]
---

# 들어가기 전에
* 이 포스트에 등장하는 모든 개념과 설명의 출처는 갓갓 교과서 __토비의 스프링__ 임.

# 오브젝트와 의존 관계
  스프링은 자바를 기반으로 한 프레임워크, 그럼 스프링이 무엇을 하고, 뭘 중요하게 여기는 프레임워크인지 확인해 보아야 한다.

* 우리의 핵심목표는 __오브젝트__ 이다 하는 것을 정신을 차리고 나아가면(후략)
    * 오브젝트가 __생성__ 되어 다른 오브젝트와 __관계__ 를 맺고, __사용__ 후 __소멸__ 되는 과정에 주목할 필요가 있다
* 우리는 DI와 IoC랑 AOP와 같은 태크닉을 넘어 결국 다시 OOP로 돌아오게 될 것이다.
    * OOP의 기초와 원칙, 다양한 디자인 패턴, 리팩토링, 검증에 이르는 광범위한 지식이 필요함.
* 스프링은 강요하지 않지만 기준을 준다

# 관심사의 분리
* 한 오브젝트, 한 메서드 안에는 다양한 관심 분야가 있다.
    * 예를 들어, DAO를 만들어보자
        * DAO 하나를 만드는 당신은 SQL에 접속, 쿼리, 결과값 핸들링, 자원 해제등의 __관심__ 이 생길 것이다.
        * 이런 관심사들을 조각내야 적절한 확장과 은폐가 가능해지는 것.
* 객체는 __항상 변하며,__ 당신은 새로운 요구조건(예시 : DB가 MySQL에서 오라클로 바뀐다거나)에 대응하기 위해 __예쁜__ 객체를 만들어야 할 필요가 있다.
    * __분리__ 와 __확장__ 을 고려한 설계가 필요하다.
* __관심사의 분리__ : 관심이 같은 것 끼리는 하나의 객체에(혹은 최대한 가까이), 관심사가 다른 종목은 최대한 멀리 떨어뜨린다
    * __효과__ : 관심이 다른 기능, 스펙이 변경될 때 그것과 연관된 다른 객체들에 미치는 영향을 최소화 할 수 있음.
* __필요한 이유__ : 우선, 일반적으로 어떤 모양의 코드에서 관심사의 분리가 필요한지 보자.
    * __일반적인 예시__ : 코드의 중복, 서로 다른 관심을 가진 코드가 한 메서드 안에 혼재
    * __예상되는 결과__ : 한 관심사를 확장, 수정할 때 다른 관심의 코드들이 ___대단히___ 큰 영향을 받음.
    * __문제점__ : = 스파게티 코드가

## 분리 방법
* 중복되는 부분 추출, 다른 관심사의 코드 부분을 분리
* 해당 코드가 원래 위치했던 곳에서는 분리해서 생성한 메서드를 사용하게 할 수 있다.

## 결과
* 관심사에 따라 코드가 분리되어, 어떤 관심에 대한 내용이 변경되었을 때에는 그 코드만 수정하면 전체 코드에 반영된다!

# 분리와 확장의 단계
* 메서드 __추출__
* 메서드 추출 후 확장을 위한 __상속__ 활용
    * 추상 메서드를 활용한다
    * 해당 클래스를 사용할 때, 추상 메서드 부분을 __스펙에 맞게__ 입맛대로 만들면 순식간에 나를 위한 클래스가 되신다.
        * 슈퍼클래스에 기본적 로직의 흐름을 만들고, 그 흐름의 일부에 사용되는 메서드를 프로텍트나 추상 메서드로 처리하여 입맛에 맞게 구현하는 방법을 __템플릿 메서드 패턴__ 이라 한다고 한다.
        * 서브클래스에서 어떤 클래스의 오브젝트를 어떻게 생성할지 고르게 하는 것은 __팩토리 메서드 패턴__ 이라고 한다.
            * 팩토리 메서드에 따라 같은 객체가 같은 방식으로 생성되어 반환될 수도, 다른 방식으로 생성되어 반환될 수도 있다.
    * 핵심 요약 : 성격이 다른 코드 부분을 분리하고, 상속을 통해 그것을 알아서 구현함.
    * 문제점 : 상속은 그다지 좋은 해결법이 아니다(물론 나쁘다는 것도 아니다)
* 아예 클래스 단위로 떼어내면 안돼?
    * 객체세스 메이커
    * 다른 관심사를 가진 코드를 클래스에서 떼어내서, 해당 관심사의 핵심 객체를 만들어내는 클래스를 만들면 되는 것 아닐까?
    * 그런데 어떻게 객체를 만드는 부분의 이름을 통일시키지? -> __인터페이스__
        * 코드는 없다! 변수도 없다! 그러나 명세는 있다!
        * 이 이름이 어떤 일을 한다는 것을 정확히 명시하여 그 동작이 이루어지게 __알아서 잘__ 구현하도록 한다.
        * 그리고 원래 클래스의 로직에서는 인터페이스에 명시된 메서드만 사용하면 된다, 내용은 알아서 잘 구현되어 있을 것이기 때문에.
    * 음.... 그래, 다 좋았어. 그런데 그래도 원래 클래스는 인터페이스를 구현한 __실제 구현 클래스__ 를 알아야 하는거 아니냐?
        * 그래서 DI가 나옵니다 친구들!
* 원 클래스에 인터페이스의 인스턴스를 때려박는 방법의 등장
    * 생성자도 세터도 상관이 없으니 `this.뫄뫄 = 밖에서 만들어진 뫄뫄;` 만 가능하면 됨.
    * 원 클래스를 상속한 다른 클래스도 이 인터페이스 기반의 구현체를 써먹을 수 있으니 메데타시 메데타시.

# 오브젝트 구성의 원칙과 패턴

## 개방 폐쇄 원칙
* = 클래스나 모듈은 확장에는 __열려__ 있어야 하고, 변경에는 __닫혀__ 있어야 한다.

## 높은 응집도와 낮은 결합도
* 응집도가 높음 = 하나의 모듈, 클래스는 하나의 책임, 관심사에만 집중되어 있다
    * 변화가 일어날 때 해당 모듈에서 변하는 부분이 큼
    * 이것 저것 섞인 잡탕이라면 어떤 관심에서 큰 변화가 있더라도 전체적으론 글쎄....
        * 애초에 변화가 가능할지도 의문
    * 무엇을 변경할지 명확, 다른 관심에 영향이 없거나 적음
* 결합도가 낮음 = 느슨-한 연결
    * 관계 유지에 최소한의 방법과 간접적 형태를 사용.
    * 세부 사항은 알지도 못하고 알 필요도 없고 독립적임.
    * 낮으면 낮을수록 변화에 대응하는 속도가 높아지고 구성이 깔끔, 확장도 편리.
    * 결합도 : 하나의 오브젝트가 변경되었을 때, 관계를 맺는 다른 오브젝트에게 변화를 요구하는 정도.

## 전략 패턴
* 어떤 객체, 메서드 등 단위의 기능 맥락에서, 필요에 따라 변경이 있을 수 있는 알고리즘 부분을 들어내 __외부로 분리__ 시키고, 이 들어낸 부분의 알고리즘을 __필요에 따라 바꿔 사용__ 할 수 있게 하는 패턴.